================================================================================
SPARQL ENDPOINT CONNECTIVITY MODULE - ARCHITECTURE DIAGRAM
================================================================================

PROJECT STRUCTURE
================================================================================

sparql-agent/
├── src/sparql_agent/discovery/
│   ├── __init__.py                    [Exports all connectivity classes]
│   └── connectivity.py                [Main implementation - 858 lines]
│       ├── EndpointStatus (Enum)
│       ├── EndpointHealth (Dataclass)
│       ├── ConnectionConfig (Dataclass)
│       ├── RateLimiter (Class)
│       ├── ConnectionPool (Class)
│       └── EndpointPinger (Class)     [Main API]
│
├── examples/
│   ├── connectivity_examples.py       [10 comprehensive examples]
│   ├── connectivity_quickstart.py     [Copy-paste patterns]
│   └── connectivity_reference.txt     [Quick reference card]
│
├── tests/
│   ├── test_connectivity.py           [Full integration test]
│   └── test_connectivity_standalone.py [Standalone test]
│
└── docs/
    ├── CONNECTIVITY_README.md         [Full documentation]
    ├── AGENT_2A_SUMMARY.md           [Implementation summary]
    ├── IMPLEMENTATION_COMPLETE.txt    [Completion status]
    └── connectivity_architecture.txt  [This file]


CLASS HIERARCHY
================================================================================

                      ┌─────────────────────┐
                      │  EndpointPinger     │  Main API
                      │  ─────────────────  │
                      │  + ping_sync()      │
                      │  + ping_async()     │
                      │  + ping_multiple_*()│
                      │  + record_health()  │
                      │  + get_uptime_%()   │
                      └──────────┬──────────┘
                                 │
                ┌────────────────┼────────────────┐
                │                │                │
                ▼                ▼                ▼
        ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
        │ConnectionPool│  │ RateLimiter  │  │ Health       │
        │──────────────│  │──────────────│  │ History      │
        │httpx.Client  │  │Token Bucket  │  │──────────────│
        │requests.Sess │  │Algorithm     │  │Deque per URL │
        └──────────────┘  └──────────────┘  └──────────────┘
                │
                └─────────────────────┐
                                      │
                         ┌────────────▼─────────────┐
                         │   ConnectionConfig       │
                         │   ──────────────────     │
                         │   timeout, ssl, auth,    │
                         │   retry, headers, etc.   │
                         └──────────────────────────┘

HEALTH CHECK RESULT FLOW
================================================================================

                    ┌──────────────────┐
                    │ EndpointHealth   │  Result Object
                    │ ──────────────── │
                    │ • endpoint_url   │
                    │ • status         │───► EndpointStatus (Enum)
                    │ • response_time  │    ├─ HEALTHY
                    │ • status_code    │    ├─ DEGRADED
                    │ • ssl_valid      │    ├─ UNHEALTHY
                    │ • ssl_expiry     │    ├─ UNREACHABLE
                    │ • error_message  │    ├─ TIMEOUT
                    │ • timestamp      │    ├─ SSL_ERROR
                    │ • server_info    │    ├─ AUTH_REQUIRED
                    │ • capabilities   │    └─ AUTH_FAILED
                    │ • to_dict()      │
                    └──────────────────┘


HEALTH CHECK EXECUTION FLOW
================================================================================

 User Code
    │
    │  ping_sync() or ping_async()
    ▼
┌─────────────────────────────────────────────────────────┐
│ EndpointPinger                                          │
│                                                         │
│  1. Rate Limiting Check                                │
│     ├─► RateLimiter.acquire()                          │
│     └─► Wait if rate exceeded                          │
│                                                         │
│  2. Retry Loop (configurable attempts)                 │
│     │                                                   │
│     ├─► Attempt 1: Immediate                           │
│     ├─► Attempt 2: Wait retry_delay                    │
│     ├─► Attempt 3: Wait retry_delay * backoff          │
│     └─► Attempt N: Wait retry_delay * backoff^(N-1)    │
│         │                                               │
│         ▼                                               │
│     ┌───────────────────────────────┐                  │
│     │ Execute Request               │                  │
│     │ ─────────────────────────     │                  │
│     │ a) Get Connection from Pool   │◄─── ConnectionPool
│     │ b) Start Timer                │                  │
│     │ c) Execute HTTP Request       │                  │
│     │    (HEAD or GET with query)   │                  │
│     │ d) Stop Timer                 │                  │
│     │ e) Check SSL Certificate      │                  │
│     │ f) Extract Server Info        │                  │
│     │ g) Detect Capabilities        │                  │
│     └───────────────────────────────┘                  │
│                                                         │
│  3. Build EndpointHealth Result                        │
│     └─► Return to caller                               │
└─────────────────────────────────────────────────────────┘


DUAL INTERFACE ARCHITECTURE
================================================================================

                      ┌─────────────────────┐
                      │  EndpointPinger     │
                      └──────────┬──────────┘
                                 │
                ┌────────────────┴────────────────┐
                │                                 │
                ▼                                 ▼
    ┌──────────────────────┐        ┌──────────────────────┐
    │  ASYNC INTERFACE     │        │  SYNC INTERFACE      │
    │  ──────────────────  │        │  ──────────────────  │
    │  • ping_async()      │        │  • ping_sync()       │
    │  • ping_multiple_*() │        │  • ping_multiple_*() │
    │  • async with        │        │  • with context mgr  │
    └──────────┬───────────┘        └──────────┬───────────┘
               │                               │
               ▼                               ▼
    ┌──────────────────────┐        ┌──────────────────────┐
    │  httpx.AsyncClient   │        │  requests.Session    │
    │  ──────────────────  │        │  ──────────────────  │
    │  • async/await       │        │  • blocking calls    │
    │  • concurrent        │        │  • sequential        │
    │  • non-blocking      │        │  • compatible        │
    └──────────────────────┘        └──────────────────────┘


RATE LIMITING - TOKEN BUCKET ALGORITHM
================================================================================

    Time ──────────────────────────────────────────►
             │           │           │           │
             │           │           │           │
    ┌────────▼───────────▼───────────▼───────────▼───────┐
    │  Token Bucket                                       │
    │  ────────────                                       │
    │                                                     │
    │  Capacity: burst                                    │
    │  Refill Rate: rate tokens/second                    │
    │                                                     │
    │  [●][●][●][●][●]                                    │
    │   ↑  ↑  ↑  ↑  ↑                                     │
    │   │  │  │  │  └─ Token 5                            │
    │   │  │  │  └──── Token 4                            │
    │   │  │  └─────── Token 3                            │
    │   │  └────────── Token 2                            │
    │   └───────────── Token 1                            │
    │                                                     │
    │  Request:                                           │
    │  ├─ Token available? Take it, proceed              │
    │  └─ No token? Wait until refill                     │
    └─────────────────────────────────────────────────────┘

    Example: rate=2.0, burst=5
    ├─ Max 2 requests/second sustained
    └─ Can burst up to 5 requests immediately


CONNECTION POOL ARCHITECTURE
================================================================================

    ┌─────────────────────────────────────────────────────┐
    │  ConnectionPool                                     │
    │  ──────────────                                     │
    │                                                     │
    │  Async Pool:                                        │
    │  ┌─────────────────────────────────────────┐       │
    │  │ httpx.AsyncClient                       │       │
    │  │ ─────────────────────────────           │       │
    │  │ Connections: [C1][C2][C3]...[C10]       │       │
    │  │ Keepalive:   [K1][K2][K3][K4][K5]       │       │
    │  └─────────────────────────────────────────┘       │
    │                                                     │
    │  Sync Pool:                                         │
    │  ┌─────────────────────────────────────────┐       │
    │  │ requests.Session                        │       │
    │  │ ─────────────────────────────           │       │
    │  │ Connections: [C1][C2][C3]...[C10]       │       │
    │  │ Keepalive:   [K1][K2][K3][K4][K5]       │       │
    │  └─────────────────────────────────────────┘       │
    │                                                     │
    │  Benefits:                                          │
    │  • Connection reuse (3-5x faster)                   │
    │  • Reduced overhead                                 │
    │  • Automatic cleanup                                │
    └─────────────────────────────────────────────────────┘


RETRY LOGIC - EXPONENTIAL BACKOFF
================================================================================

    Attempt 1:  [REQUEST] ─X─ Failed
                    │
                    │  No delay
                    │
    Attempt 2:  [WAIT 1s] ───► [REQUEST] ─X─ Failed
                    │
                    │  Wait retry_delay * backoff^0 = 1s
                    │
    Attempt 3:  [WAIT 2s] ───► [REQUEST] ─X─ Failed
                    │
                    │  Wait retry_delay * backoff^1 = 2s
                    │
    Attempt 4:  [WAIT 4s] ───► [REQUEST] ─✓─ Success!
                    │
                    │  Wait retry_delay * backoff^2 = 4s
                    │
                    ▼
              Return Result


HEALTH STATUS DETERMINATION
================================================================================

    HTTP Response
         │
         ▼
    ┌──────────────────────────────────────────────┐
    │ Status Code Analysis                         │
    │ ────────────────────                         │
    │                                              │
    │ 200-299 + Response < 1s    ──► HEALTHY      │
    │ 200-299 + Response 1-5s    ──► DEGRADED     │
    │ 200-299 + Response > 5s    ──► UNHEALTHY    │
    │ 401                        ──► AUTH_REQUIRED │
    │ 403                        ──► AUTH_FAILED   │
    │ 4XX/5XX                    ──► UNHEALTHY    │
    │ Timeout                    ──► TIMEOUT       │
    │ SSL Error                  ──► SSL_ERROR     │
    │ Connection Failed          ──► UNREACHABLE   │
    │                                              │
    └──────────────────────────────────────────────┘


USAGE PATTERN MATRIX
================================================================================

┌────────────────┬──────────────┬──────────────┬─────────────┐
│ Use Case       │ Interface    │ Method       │ check_query │
├────────────────┼──────────────┼──────────────┼─────────────┤
│ Quick Check    │ Sync         │ ping_sync    │ False       │
│ Full Test      │ Sync         │ ping_sync    │ True        │
│ Single Async   │ Async        │ ping_async   │ False       │
│ Multiple Seq   │ Sync         │ ping_multi_s │ False       │
│ Multiple Conc  │ Async        │ ping_multi_a │ False       │
│ Rate Limited   │ Async        │ ping_multi_a │ False       │
│ With Auth      │ Either       │ ping_*       │ Either      │
│ History Track  │ Either       │ + record_h   │ Either      │
└────────────────┴──────────────┴──────────────┴─────────────┘


DATA FLOW EXAMPLE
================================================================================

    User Code:
    ──────────
    pinger = EndpointPinger(rate_limit=(2.0, 5))
    health = await pinger.ping_async('https://sparql.uniprot.org/sparql')

    Internal Flow:
    ──────────────
    1. RateLimiter.acquire()
       ├─ Check token bucket
       ├─ Wait if necessary
       └─ Consume token

    2. ConnectionPool.get_async_client()
       ├─ Return existing client
       └─ Or create new one

    3. Execute Request
       ├─ Start timer (time.monotonic)
       ├─ httpx.get(url, params={'query': 'ASK { ?s ?p ?o }'})
       ├─ Stop timer
       └─ Calculate response_time_ms

    4. Check SSL
       ├─ asyncio.open_connection(host, 443, ssl=context)
       ├─ Get certificate
       ├─ Parse expiry date
       └─ Close connection

    5. Analyze Response
       ├─ Check status_code
       ├─ Extract headers
       ├─ Detect capabilities
       └─ Determine EndpointStatus

    6. Build Result
       └─ EndpointHealth(
             endpoint_url='...',
             status=EndpointStatus.HEALTHY,
             response_time_ms=234.56,
             status_code=200,
             ssl_valid=True,
             ssl_expiry=datetime(2025, 12, 31),
             ...
           )

    7. Return to User
       └─ health.status.value == 'healthy'


INTEGRATION POINTS
================================================================================

┌─────────────────────────────────────────────────────────────┐
│ sparql_agent Package                                        │
│                                                             │
│  ┌────────────────────────────────────────┐                │
│  │ discovery Module                       │                │
│  │                                        │                │
│  │  • EndpointPinger  ◄────┐             │                │
│  │  • EndpointHealth        │             │                │
│  │  • EndpointStatus        │             │                │
│  │  • ConnectionConfig      │             │                │
│  └──────────────────────────┼─────────────┘                │
│                             │                              │
│  ┌──────────────────────────┼─────────────┐                │
│  │ core Module              │             │                │
│  │                          │             │                │
│  │  • SPARQLAgent ──────────┘             │                │
│  │    (can use EndpointPinger for         │                │
│  │     health checks before queries)      │                │
│  └────────────────────────────────────────┘                │
│                                                             │
│  ┌────────────────────────────────────────┐                │
│  │ monitoring Module (future)             │                │
│  │                                        │                │
│  │  • EndpointMonitor ◄───────────────────┼─────┐          │
│  │    (could use EndpointPinger for       │     │          │
│  │     continuous monitoring)             │     │          │
│  └────────────────────────────────────────┘     │          │
│                                                 │          │
└─────────────────────────────────────────────────┼──────────┘
                                                  │
                                                  │
                                          User Application


PERFORMANCE METRICS
================================================================================

    Scenario: Ping 10 endpoints concurrently

    Sequential (Sync):
    ──────────────────
    [E1] [E2] [E3] [E4] [E5] [E6] [E7] [E8] [E9] [E10]
    ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤
    0   200  400  600  800  1s  1.2s 1.4s 1.6s 1.8s  2s

    Total: ~2000ms

    Concurrent (Async):
    ───────────────────
    [E1]
    [E2]
    [E3]
    [E4]
    [E5]  All executed in parallel
    [E6]
    [E7]
    [E8]
    [E9]
    [E10]
    ├────┤
    0   250ms (slowest endpoint)

    Total: ~250ms (8x faster!)


RESOURCE USAGE
================================================================================

    Per EndpointPinger Instance:
    ────────────────────────────
    Memory:
    • Base: ~10 KB
    • Per connection: ~50 KB
    • Pool of 10: ~510 KB total

    CPU:
    • Minimal (I/O bound)
    • <1% during health checks
    • Rate limiting: <0.1% overhead

    Network:
    • HEAD request: ~500 bytes
    • GET with query: ~2-5 KB
    • Response: Varies by endpoint


DEPENDENCIES TREE
================================================================================

    connectivity.py
    ├── Python Standard Library
    │   ├── asyncio (async support)
    │   ├── ssl (SSL/TLS validation)
    │   ├── time (timing, delays)
    │   ├── dataclasses (data structures)
    │   ├── enum (status enumeration)
    │   ├── logging (error logging)
    │   ├── collections (deque for history)
    │   ├── datetime (timestamps)
    │   └── urllib.parse (URL parsing)
    │
    └── External Libraries (optional)
        ├── httpx >= 0.27.0 (async HTTP)
        └── requests >= 2.31.0 (sync HTTP)


================================================================================
END OF ARCHITECTURE DOCUMENTATION
================================================================================
